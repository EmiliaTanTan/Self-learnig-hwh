OOP!!!
  代码区： 操作系统管理， 里面存放的是二进制代码
  全局区： 学了sicp后， 最重要的概念--frame chain
  栈区： 编译器自动分配， 释放
  堆区： 程序员分配和释放， 程序结束时会被系统回收掉

程序运行前：
    编译后， 生成了exe可执行程序， 在我们还没有执行前;
    代码区：
        CPU的机器指令
        1.共享  频繁执行的程序， 在内存中只需要有一段代码了 2.只读
    全局区：
        存放了全局变量，静态变量，常量
        由操作系统管理生命周期
        写在函数体内的， 都叫做局部变量（包括main函数！！）、
        静态变量： 在普通变量前面， 加上static
        常量： 字符串常量， const 修饰的常量
        // question? 哪些东西不在全局区中?
            Ans：局部变量， const 修饰的局部变量
        // question? 宏常量存放在哪里？
            Ans: 宏的本质是替换， 也就是说， 其实宏定义出来的东西不占用内存(情理之中(●'◡'●))

程序运行后：
    栈区： 由编译器自动分配和释放
        函数的形式参数， 局部变量
        Warning: 不要试图返回局部变量的地址！！ 栈区开辟的数据， 会由编译器自动释放
            Demo:
                int* func()
                    {
                        int a = 10;
                        return &a;
                    }
                // 返回的东西， 不是我们想要的， 因为里面存储的10已经被释放了 ， 这就是， 生命期的概念
        总结： 1.栈区存放： 局部变量和形参 2.不要试图返回局部变量的地址

    堆区： 由程序员自己管理
        // 铺垫， 聪明的wjhwh小朋友发现了一种新的赋值方法， 这种方法在以后学习面向对象的时候也会经常用到
                int a(10);
                cout << a << endl; // 输出结果为 10
        // new int(10) 
              上面的语句返回结果是一个地址， 这个内存里面， 我们已经实现存储了整型数据 10
        指针的本质， 也是一个局部变量， 存储在栈区， 指针保存的数据放在了堆区
        知道了吗？ 之前我们之所以不让返回局部变量的地址， 是因为， 局部变量的生死， 由编译器自己管理
        但是现在！！！ 我们自己开辟了堆区的内存， 我们可以自己管理这块内存！！
        利用delete关键字， 可以方便我们释放内存
        int* arr = new int[10]; // 创建长度为10的整型数组
        释放数组的时候， 需要 delete[] arr才可以

      
